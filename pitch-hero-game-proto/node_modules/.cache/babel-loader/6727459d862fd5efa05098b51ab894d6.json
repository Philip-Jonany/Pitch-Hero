{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\phili\\\\Documents\\\\GitHub\\\\Pitch-Hero\\\\pitch-hero-game-proto\\\\src\\\\Game.tsx\";\nimport React from \"react\";\nimport { Component } from \"react\";\nimport GameTimer from \"./GameTimer\";\nimport { PipeEntity, PlayerEntity } from \"./GameEntities\";\nimport { GamePhase } from \"./GameTypes\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass Game extends Component {\n  constructor(props) {\n    super(props);\n    this.canvas = void 0;\n\n    this.initInfo = () => {\n      return {\n        score: 0\n      };\n    };\n\n    this.getInputFunc = () => this.props.input;\n\n    this.initGame = () => {\n      this.transitionPhase(GamePhase.INIT);\n    };\n\n    this.transitionPhase = nextPhase => {\n      let lastPhase = this.state.phase;\n      this.setState({\n        phase: nextPhase\n      }, () => {\n        var _this$props$onPhaseCh, _this$props;\n\n        (_this$props$onPhaseCh = (_this$props = this.props).onPhaseChangeCallback) === null || _this$props$onPhaseCh === void 0 ? void 0 : _this$props$onPhaseCh.call(_this$props, lastPhase, this.state.phase, this.state.info);\n      });\n    };\n\n    this.tickGame = dt => {\n      let player;\n      let entities;\n      let EID = this.state.nextEID;\n\n      switch (this.state.phase) {\n        case GamePhase.INIT:\n          // start updating game on the next frame\n          player = new PlayerEntity(EID++, this.getInputFunc);\n          entities = [];\n          entities.push(player);\n          this.setState({\n            entities: entities,\n            nextEID: EID,\n            player: player,\n            sinceLastPipe: Infinity,\n            info: this.initInfo()\n          });\n          this.transitionPhase(GamePhase.ALIVE);\n          break;\n\n        case GamePhase.ALIVE:\n          // check to make sure the player hasn't died\n          player = this.state.player; // player is definitely not null\n\n          entities = this.state.entities;\n\n          if (this.state.entities.some(e => e.name === \"pipe\" && e.inDangerZone(player.x, player.y)) || player.y < 0 || player.y > 100) {\n            // there's at least one pipe we're in the danger zone of, we died :(\n            this.transitionPhase(GamePhase.DEAD);\n            break;\n          } // check to see how long it's been since we spawned a pipe; if it's been 3 seconds, spawn a new pipe\n\n\n          let sinceLastPipe = this.state.sinceLastPipe;\n\n          if (sinceLastPipe > 3) {\n            this.state.entities.push(new PipeEntity(EID++, Math.random() * 60 + 20, 5, 20));\n            sinceLastPipe = 0;\n          } // update score for every pipe the player is past the danger zone of and hasn't yet awarded points\n\n\n          let info = this.state.info;\n          this.state.entities.filter(e => e.name === \"pipe\").map(e => {\n            let pipe = e;\n\n            if (pipe.x + pipe.width / 2 < player.x && !pipe.awardedPoints) {\n              info.score++;\n              pipe.awardedPoints = true;\n            }\n\n            return e;\n          }); // tick each entity\n\n          this.state.entities.map(e => {\n            e.tick(dt);\n            return e;\n          }); // queue a setstate to update entities, remove any entities that should be dead\n\n          this.setState({\n            entities: this.state.entities.filter(e => !e.shouldRemove()),\n            nextEID: EID,\n            sinceLastPipe: sinceLastPipe + dt,\n            info: info\n          });\n          break;\n\n        case GamePhase.DEAD:\n          // sit forever without doing any special ticking, we're dead lol\n          break;\n\n        case GamePhase.PAUSED:\n          // sit forever, unpausing only happens externally\n          break;\n\n        case GamePhase.UNPAUSED:\n          // we want to unpause, return to whatever the state was beforehand\n          this.transitionPhase(this.state.prePausePhase);\n          this.setState({\n            prePausePhase: GamePhase.INIT\n          });\n          break;\n      }\n    };\n\n    this.drawGame = dt => {\n      let canvas = this.canvas.current;\n      let ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(\"2d\");\n\n      if (canvas && ctx) {\n        canvas.width = this.props.width;\n        canvas.height = this.props.height; // background\n\n        ctx.fillStyle = \"blue\";\n        ctx.beginPath();\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        this.state.entities.map(e => {\n          e.draw(dt, canvas, ctx);\n          return e;\n        });\n      }\n    };\n\n    this.state = {\n      phase: GamePhase.INIT,\n      entities: [],\n      nextEID: 0,\n      player: null,\n      sinceLastPipe: 0,\n      info: this.initInfo(),\n      prePausePhase: GamePhase.INIT\n    };\n    this.canvas = /*#__PURE__*/React.createRef();\n  }\n\n  componentDidMount() {\n    this.initGame();\n  }\n\n  componentDidUpdate() {\n    if (this.props.requestedPhase !== this.state.phase) {\n      // someone wants us to externally change the game phase, try to do so if possible\n      switch (this.props.requestedPhase) {\n        case GamePhase.INIT:\n          // always allow resetting the game\n          this.transitionPhase(GamePhase.INIT);\n          break;\n\n        case GamePhase.PAUSED:\n          this.setState({\n            prePausePhase: this.state.phase\n          });\n          this.transitionPhase(GamePhase.PAUSED);\n          break;\n\n        case GamePhase.UNPAUSED:\n          this.transitionPhase(GamePhase.UNPAUSED);\n          break;\n      }\n    }\n  }\n\n  render() {\n    var _this$state$player, _this$state$player2;\n\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"Game\",\n      children: [/*#__PURE__*/_jsxDEV(GameTimer, {\n        onTickCallback: this.tickGame,\n        postTickCallback: this.drawGame\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 196,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Game Phase: \", this.state.phase]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 200,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"X position: \", (_this$state$player = this.state.player) === null || _this$state$player === void 0 ? void 0 : _this$state$player.x]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 201,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Y position: \", (_this$state$player2 = this.state.player) === null || _this$state$player2 === void 0 ? void 0 : _this$state$player2.y]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 202,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Score: \", this.state.info.score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 203,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n        className: \"gameCanvas\",\n        ref: this.canvas\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 205,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\nexport default Game;","map":{"version":3,"sources":["C:/Users/phili/Documents/GitHub/Pitch-Hero/pitch-hero-game-proto/src/Game.tsx"],"names":["React","Component","GameTimer","PipeEntity","PlayerEntity","GamePhase","Game","constructor","props","canvas","initInfo","score","getInputFunc","input","initGame","transitionPhase","INIT","nextPhase","lastPhase","state","phase","setState","onPhaseChangeCallback","info","tickGame","dt","player","entities","EID","nextEID","push","sinceLastPipe","Infinity","ALIVE","some","e","name","inDangerZone","x","y","DEAD","Math","random","filter","map","pipe","width","awardedPoints","tick","shouldRemove","PAUSED","UNPAUSED","prePausePhase","drawGame","current","ctx","getContext","height","fillStyle","beginPath","fillRect","draw","createRef","componentDidMount","componentDidUpdate","requestedPhase","render"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport { Component } from \"react\";\r\nimport GameTimer from \"./GameTimer\";\r\nimport { GameEntity, PipeEntity, PlayerEntity } from \"./GameEntities\";\r\nimport { GameInfo, GamePhase } from \"./GameTypes\";\r\n\r\ninterface GameProps {\r\n  width: number,\r\n  height: number,\r\n  input: number,\r\n  requestedPhase: GamePhase | null,    // externally requested state change\r\n  onPhaseChangeCallback?(lastPhase: GamePhase, newPhase: GamePhase, info: GameInfo): void\r\n}\r\n\r\ninterface GameState {\r\n  phase: GamePhase,\r\n  entities: GameEntity[],\r\n  nextEID: number,\r\n  player: PlayerEntity | null\r\n  sinceLastPipe: number,\r\n  info: GameInfo,\r\n  prePausePhase: GamePhase\r\n}\r\n\r\nclass Game extends Component<GameProps, GameState> {\r\n  canvas: React.RefObject<HTMLCanvasElement>;\r\n\r\n  constructor(props: any) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      phase: GamePhase.INIT,\r\n      entities: [],\r\n      nextEID: 0,\r\n      player: null,\r\n      sinceLastPipe: 0,\r\n      info: this.initInfo(),\r\n      prePausePhase: GamePhase.INIT\r\n    }\r\n\r\n    this.canvas = React.createRef();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.initGame()\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    if (this.props.requestedPhase !== this.state.phase) {\r\n      // someone wants us to externally change the game phase, try to do so if possible\r\n      switch(this.props.requestedPhase) {\r\n        case GamePhase.INIT:\r\n          // always allow resetting the game\r\n          this.transitionPhase(GamePhase.INIT);\r\n          break;\r\n        case GamePhase.PAUSED:\r\n          this.setState({ prePausePhase: this.state.phase });\r\n          this.transitionPhase(GamePhase.PAUSED);\r\n          break;\r\n        case GamePhase.UNPAUSED:\r\n          this.transitionPhase(GamePhase.UNPAUSED);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  initInfo = () => {\r\n    return {\r\n      score: 0\r\n    };\r\n  }\r\n\r\n  getInputFunc = () => this.props.input;\r\n\r\n  // game startup/reset; run once when game starts up/resets\r\n  initGame = () => {\r\n    this.transitionPhase(GamePhase.INIT);\r\n  }\r\n\r\n  transitionPhase = (nextPhase: GamePhase) => {\r\n    let lastPhase = this.state.phase;\r\n\r\n    this.setState({ phase: nextPhase }, () => {\r\n      this.props.onPhaseChangeCallback?.(lastPhase, this.state.phase, this.state.info)\r\n    });\r\n  }\r\n\r\n  // game tick, called once every frame\r\n  // dt: time in seconds since last frame\r\n  tickGame = (dt : number) => {\r\n    let player: PlayerEntity;\r\n    let entities: GameEntity[];\r\n    let EID = this.state.nextEID;\r\n    switch(this.state.phase) {\r\n      case GamePhase.INIT:\r\n        // start updating game on the next frame\r\n        player = new PlayerEntity(EID++, this.getInputFunc);\r\n        entities = [];\r\n        entities.push(player);\r\n\r\n        this.setState({\r\n          entities: entities,\r\n          nextEID: EID,\r\n          player: player,\r\n          sinceLastPipe: Infinity,\r\n          info: this.initInfo()\r\n        });\r\n        this.transitionPhase(GamePhase.ALIVE);\r\n        break;\r\n\r\n      case GamePhase.ALIVE:\r\n        // check to make sure the player hasn't died\r\n        player = this.state.player!;  // player is definitely not null\r\n        entities = this.state.entities;\r\n        if (this.state.entities.some((e: GameEntity) => e.name === \"pipe\" \r\n                                                        && (e as PipeEntity).inDangerZone(player.x, player.y))\r\n              || player.y < 0 || player.y > 100) {\r\n          // there's at least one pipe we're in the danger zone of, we died :(\r\n          this.transitionPhase(GamePhase.DEAD);\r\n          break;\r\n        }\r\n        \r\n        // check to see how long it's been since we spawned a pipe; if it's been 3 seconds, spawn a new pipe\r\n        let sinceLastPipe = this.state.sinceLastPipe;\r\n        if (sinceLastPipe > 3) {\r\n          this.state.entities.push(new PipeEntity(EID++, Math.random() * 60 + 20, 5, 20));\r\n          sinceLastPipe = 0;\r\n        }\r\n\r\n        // update score for every pipe the player is past the danger zone of and hasn't yet awarded points\r\n        let info = this.state.info;\r\n        this.state.entities.filter(e => e.name === \"pipe\").map(e => {\r\n          let pipe = e as PipeEntity;\r\n          if ((pipe.x + pipe.width / 2) < player.x && !pipe.awardedPoints) {\r\n            info.score++;\r\n            pipe.awardedPoints = true;\r\n          }\r\n          return e;\r\n        });\r\n        \r\n        // tick each entity\r\n        this.state.entities.map((e: GameEntity) => {\r\n          e.tick(dt);\r\n          return e;\r\n        });\r\n\r\n        // queue a setstate to update entities, remove any entities that should be dead\r\n        this.setState({\r\n          entities: this.state.entities.filter((e: GameEntity) => !e.shouldRemove()),\r\n          nextEID: EID,\r\n          sinceLastPipe: sinceLastPipe + dt,\r\n          info: info\r\n        });\r\n        break;\r\n\r\n      case GamePhase.DEAD:\r\n        // sit forever without doing any special ticking, we're dead lol\r\n        break;\r\n\r\n      case GamePhase.PAUSED:\r\n        // sit forever, unpausing only happens externally\r\n        break;\r\n      \r\n      case GamePhase.UNPAUSED:\r\n        // we want to unpause, return to whatever the state was beforehand\r\n        this.transitionPhase(this.state.prePausePhase);\r\n        this.setState({ prePausePhase: GamePhase.INIT });\r\n        break;\r\n    }\r\n  }\r\n\r\n  // render canvas, called every frame after tickGame\r\n  // note: DON'T do any setState in here\r\n  drawGame = (dt: number) => {\r\n    let canvas = this.canvas.current;\r\n    let ctx = canvas?.getContext(\"2d\");\r\n    if (canvas && ctx) {\r\n      canvas.width = this.props.width;\r\n      canvas.height = this.props.height;\r\n  \r\n      // background\r\n      ctx.fillStyle = \"blue\";\r\n      ctx.beginPath();\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n      this.state.entities.map((e: GameEntity) => {\r\n        e.draw(dt, canvas!, ctx!);\r\n        return e;\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"Game\">\r\n        <GameTimer\r\n          onTickCallback = { this.tickGame }\r\n          postTickCallback = { this.drawGame }\r\n        />\r\n        <p>Game Phase: { this.state.phase }</p>\r\n        <p>X position: { this.state.player?.x }</p>\r\n        <p>Y position: { this.state.player?.y }</p>\r\n        <p>Score: { this.state.info.score }</p>\r\n        {/*<button onClick={ this.initGame }>Reset game</button>-->*/}\r\n        <canvas className=\"gameCanvas\" ref={ this.canvas }/>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Game;\r\n"]},"metadata":{},"sourceType":"module"}